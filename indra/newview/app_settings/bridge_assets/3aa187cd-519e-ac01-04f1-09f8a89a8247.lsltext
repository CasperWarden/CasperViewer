//***********************************************************************//
//* Phoenix LSL bridge script version 0.10                              *//
//*                                                                     *//
//* This script has two functions:                                      *//
//* 1) Send radar informaion to the viewer                              *//
//* 2) Retrieve true online/offline status for a requested user         *//
//*                                                                     *//
//***********************************************************************//


//**** BEGIN VARIABLES ****//

integer debugger = FALSE;	// TRUE to enable debugging messages
integer receive_channel;	// Channel to receive from viewer on
integer tid;
integer altListenHandler;
integer listenReq;
integer startTime;
vector  moveToTarget;

integer tid2;
integer l2c;

list onlinereqs;

//**** END VARIABLES ****//

// This function prints debugging messages if selected at the top of this
//  file.
debug(string message)
{
	if (debugger)
	{
		llOwnerSay("Phoenix Bridge: "+message);
	}
}

// This function initializes the script's communications channel. It'll be
//  reset later to a randomized value, but we have to start somewhere. The
//  initial channel is set from an MD5 hash of the user's UUID.
init()
{
	receive_channel = (integer)("0x"+llGetSubString(
				llMD5String((string)llGetOwner(),1),0,6));
	debug("init: Receive channel: "+(string) receive_channel);
	connect();
}

// This function restarts the listeners to get data from the viewer.
connect()
{
	// Remove old main listener.
	llListenRemove(tid);
	// Start new main listener.
	tid = llListen(receive_channel,"",llGetOwner(),"");

	// If there was an old secondary listener,
	if(l2c != 0)
	{
		// remove it,
		llListenRemove(tid2);
		// and start a new one.
		tid2 = llListen(l2c,"",llGetOwner(),"");
	}// End If

	// If the bridge is attached (instead of rezzed on the ground),
	if(llGetAttached() != 0)
	{
		// take the viewer's controls so we still work in noscript
		//  areas. We don't actually do anything with them.
		llRequestPermissions(llGetOwner(),PERMISSION_TAKE_CONTROLS);
	}// End If
}

// This function sends data to the viewer, prefixed with a flag that tells
//  the viewer it came from the bridge.
send(string data)
{
	//if (llStringLength(data) > (1023 - 5))
	//	llOwnerSay("ERR: string too long");
	llOwnerSay("#@#@#"+data);
	debug("send: Sending '"+data+"'");
}

// This function returns a very large integer between 100000001 and 999999999.
//  Note that there will only be somewhere in the neighborhood of 24 bits
//  of randomness. See the Second Life Wiki's article on llFrand() for
//  details.
integer max_rand_integer()
{
	return (integer)((
		(llFrand(0.999998) + 0.000001) + // 0.000001 through 0.999999
		((llFrand(0.899) + 0.1) * 1000)  // 100 through 999
		) * 1000000);
}


receive(string data)
{
	list instruction = llParseString2List(data,["|"],[]); //parse message to work out what command has been issued
	integer id = (integer)llList2String(instruction,0); //this is the uuid of whatever the command refers to
	string cmd = llList2String(instruction,1); //this is the command
	if(cmd == "online_status")  // check online status of an avatar
	{
		onlinereqs += [id, llRequestAgentData((key)llList2String(instruction,2), DATA_ONLINE)];
		//llOwnerSay("processing online request");
	}// End If
	else if(cmd == "pos") // check position of requested object / avatar
	{
		list positions = [id];
		integer increment = 2;
		for(;increment<(instruction!=[]);increment++)
		{
			//send in the same order we received.
			positions += [(string)llGetObjectDetails((key)llList2String(instruction,increment),[OBJECT_POS])];
		}
		send(llDumpList2String(positions,"|"));
	}// End Else If
	else if(cmd == "listen")//for client listening on channels, 0 to stop
	{
		listenReq = id;
		llListenRemove(altListenHandler);
		integer channelToListenOn = (integer)llList2String(instruction,2);
		if(channelToListenOn)
			altListenHandler = llListen(channelToListenOn,"",NULL_KEY,"");
	}// End Else If
	else if (cmd == "move")//for client to use llMoveToTarget
	{
		moveToTarget=(vector)llList2String(instruction,2);
		startTime=llGetUnixTime();
		llSetTimerEvent(.05);
	}// End Else If
	else if(cmd == "l2c") //connection bridge to client
	{
		l2c = max_rand_integer();
		connect();
		llOwnerSay("l2c"+(string)l2c);
	}// End Else If
	else if (cmd == "loopsound") // play a sound
	{
		llSetLinkPrimitiveParamsFast(LINK_THIS,[PRIM_POSITION, llGetPos(),PRIM_POSITION, <0,0,0>]);
		string sound = llList2String(instruction,2);
		llLoopSound((key)sound, 1.0);
	}// End Else If
	else if (cmd == "stopsound") // stop attatched sound
	{
		llStopSound();
	}// End Else If
}

//**** END FUNCTIONS ****//

//**** BEGIN MAIN CODE ****//
default
{
	state_entry()
	{
		init(); // generate channels, connect to client
	} //End state entry

	
	on_rez(integer p)
	{
		init(); // generate channels, connect to client
	}// End on rez

	
	listen(integer channel, string name, key id, string message){
		if(channel == receive_channel || channel == l2c){ //if on our channels
			receive(message);	// parse it for commands and act on them
			return; //carry on
		}// End If
		send(llDumpList2String([listenReq,channel,name,id,message],"|")); // send info back
	} //End listen

	
	run_time_permissions(integer p)
	{
		if(p)llTakeControls(1024,1,1); // take controls, but do nothing with them - lets us keep going in no script areas
	} //End run time permissions

	
	dataserver(key id, string data)
	{
		integer i = llListFindList(onlinereqs,[id]); //are we checking for an avatar's online status?
		if(i != -1) // yes, we are
		{
			//llOwnerSay("returning online request");
			send((string)llList2Integer(onlinereqs,i-1)+"|"+data); //send the info to the client
			onlinereqs = llDeleteSubList(onlinereqs,i-1,i); // and clean up after ourselves
		}// End If
	} //End dataserver

	
	timer() // Used for move to pos tp's
	{
		llSetTimerEvent(0.0);
		if(llGetUnixTime() - 10 > startTime)
		{
			llStopMoveToTarget();
			return;
		}// End If
		vector us = llGetPos();
		vector dist = moveToTarget - us;
		float mag = llVecMag(dist);
		if(mag < 1.0)
		{
			llStopMoveToTarget();
			return;
		}// End If
		if(mag>45)
		{
			llMoveToTarget(us+llVecNorm(dist)*45,.05);
		}// End If
		else
		{
			llMoveToTarget(moveToTarget,.05);
		} //End Else
		llSetTimerEvent(.05);
	} //End timer
} //End Default

//**** END MAIN CODE ****//
