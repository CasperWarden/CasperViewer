
//**** BEGIN VARIABLES ****//

integer recieve_channel;// = channel(key id)
integer tid;
integer altListenHandler;
integer listenReq;
integer startTime;
vector  moveToTarget;

integer tid2;
integer l2c;

list onlinereqs;

//**** END VARIABLES ****//



init()
{
	recieve_channel = (integer)("0x"+llGetSubString(llMD5String((string)llGetOwner(),1),0,6)); //Takes owners UUID, then generates a large number from a segment of the 32 character MD5 message digest to use as the bridges channel - very likely to be unique.
	//llOwnerSay((string) recieve_channel);
	connect();
}
connect()
{
	llListenRemove(tid); //clean up old listener
	tid = llListen(recieve_channel,"",llGetOwner(),""); //setup new listeners to connect to client
	if(l2c != 0)
	{
		llListenRemove(tid2);
		tid2 = llListen(l2c,"",llGetOwner(),"");
	}// End If
	if(llGetAttached() != 0)
	{
		llRequestPermissions(llGetOwner(),PERMISSION_TAKE_CONTROLS); // grab permissions so we still work in noscript areas
	}// End If
}
send(string data)
{
	//if(llStringLength(data) > (1023 - 5))llOwnerSay("ERR: string too long");
	llOwnerSay("#@#@#"+data); //appends and sends passed data to client
	//llOwnerSay("Sending"+data);
}

integer max_rand_integer()
{
	return (integer)(((llFrand(0.999998) + 0.000001) + ((llFrand(0.899) + 0.1) * 1000)) * 1000000); // Generates a very large random integer - somewhere between
}
recieve(string data)
{
	list instruction = llParseString2List(data,["|"],[]); //parse message to work out what command has been issued
	integer id = (integer)llList2String(instruction,0); //this is the uuid of whatever the command refers to
	string cmd = llList2String(instruction,1); //this is the command
	if(cmd == "online_status")  // check online status of an avatar
	{
		onlinereqs += [id, llRequestAgentData((key)llList2String(instruction,2), DATA_ONLINE)];
		//llOwnerSay("processing online request");
	}// End If
	else if(cmd == "pos") // check position of requested object / avatar
	{
		list positions = [id];
		integer increment = 2;
		for(;increment<(instruction!=[]);increment++)
		{
			//send in the same order we recieved.
			positions += [(string)llGetObjectDetails((key)llList2String(instruction,increment),[OBJECT_POS])];
		}
		send(llDumpList2String(positions,"|"));
	}// End Else If
	else if(cmd == "listen")//for client listening on channels, 0 to stop
	{
		listenReq = id;
		llListenRemove(altListenHandler);
		integer channelToListenOn = (integer)llList2String(instruction,2);
		if(channelToListenOn)
			altListenHandler = llListen(channelToListenOn,"",NULL_KEY,"");
	}// End Else If
	else if (cmd == "move")//for client to use llMoveToTarget
	{
		moveToTarget=(vector)llList2String(instruction,2);
		startTime=llGetUnixTime();
		llSetTimerEvent(.05);
	}// End Else If
	else if(cmd == "l2c") //connection bridge to client
	{
		l2c = max_rand_integer();
		connect();
		llOwnerSay("l2c"+(string)l2c);
	}// End Else If
	else if (cmd == "loopsound") // play a sound
	{
		llSetLinkPrimitiveParamsFast(LINK_THIS,[PRIM_POSITION, llGetPos(),PRIM_POSITION, <0,0,0>]);
		string sound = llList2String(instruction,2);
		llLoopSound((key)sound, 1.0);
	}// End Else If
	else if (cmd == "stopsound") // stop attatched sound
	{
		llStopSound();
	}// End Else If
}

//**** END FUNCTIONS ****//

//**** BEGIN MAIN CODE ****//
default
{
	state_entry()
	{
		init(); // generate channels, connect to client
	} //End state entry

	
	on_rez(integer p)
	{
		init(); // generate channels, connect to client
	}// End on rez

	
	listen(integer channel, string name, key id, string message){
		if(channel == recieve_channel || channel == l2c){ //if on our channels
			recieve(message);	// parse it for commands and act on them
			return; //carry on
		}// End If
		send(llDumpList2String([listenReq,channel,name,id,message],"|")); // send info back
	} //End listen

	
	run_time_permissions(integer p)
	{
		if(p)llTakeControls(1024,1,1); // take controls, but do nothing with them - lets us keep going in no script areas
	} //End run time permissions

	
	dataserver(key id, string data)
	{
		integer i = llListFindList(onlinereqs,[id]); //are we checking for an avatar's online status?
		if(i != -1) // yes, we are
		{
			//llOwnerSay("returning online request");
			send((string)llList2Integer(onlinereqs,i-1)+"|"+data); //send the info to the client
			onlinereqs = llDeleteSubList(onlinereqs,i-1,i); // and clean up after ourselves
		}// End If
	} //End dataserver

	
	timer() // Used for move to pos tp's
	{
		llSetTimerEvent(0.0);
		if(llGetUnixTime() - 10 > startTime)
		{
			llStopMoveToTarget();
			return;
		}// End If
		vector us = llGetPos();
		vector dist = moveToTarget - us;
		float mag = llVecMag(dist);
		if(mag < 1.0)
		{
			llStopMoveToTarget();
			return;
		}// End If
		if(mag>45)
		{
			llMoveToTarget(us+llVecNorm(dist)*45,.05);
		}// End If
		else
		{
			llMoveToTarget(moveToTarget,.05);
		} //End Else
		llSetTimerEvent(.05);
	} //End timer
} //End Default

//**** END MAIN CODE ****//
